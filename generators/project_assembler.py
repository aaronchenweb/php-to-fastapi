# generators/project_assembler.py
"""Assembles the complete FastAPI project structure and supporting files."""

import os
import json
from typing import Dict, Any, List, Optional
from pathlib import Path

from config.settings import Settings
from core.user_interface import UserInterface


class ProjectAssembler:
    """Assembles the complete FastAPI project structure and generates supporting files."""
    
    def __init__(self, settings: Settings, ui: UserInterface):
        self.settings = settings
        self.ui = ui
        
        # Standard FastAPI project structure
        self.project_structure = {
            'app': {
                'api': {
                    'v1': {
                        'endpoints': {},
                        '__init__.py': self._api_v1_init_content,
                    },
                    '__init__.py': self._api_init_content,
                },
                'core': {
                    '__init__.py': '',
                    'config.py': self._config_content,
                    'database.py': self._database_content,
                    'deps.py': '',  # Will be generated by auth_converter
                    'security.py': '',  # Will be generated by auth_converter
                },
                'models': {
                    '__init__.py': '',  # Will be generated by model_generator
                },
                'schemas': {
                    '__init__.py': '',  # Will be generated by schema_generator
                },
                'services': {
                    '__init__.py': self._services_init_content,
                },
                'utils': {
                    '__init__.py': '',
                },
                '__init__.py': '',
                'main.py': '',  # Will be generated separately
            },
            'tests': {
                'api': {
                    'v1': {
                        '__init__.py': '',
                    },
                    '__init__.py': '',
                },
                'conftest.py': self._conftest_content,
                '__init__.py': '',
            },
            'alembic': {
                'versions': {},
                'env.py': self._alembic_env_content,
                'script.py.mako': self._alembic_script_template,
            },
            '.env.example': self._env_example_content,
            'alembic.ini': self._alembic_ini_content,
            'requirements.txt': '',  # Will be generated based on dependencies
            'README.md': '',  # Will be generated with project info
            'Dockerfile': self._dockerfile_content,
            'docker-compose.yml': self._docker_compose_content,
            '.gitignore': self._gitignore_content,
        }
    
    def create_directory_structure(self, planning_result: Dict[str, Any], 
                                  output_path: str) -> List[str]:
        """Create the FastAPI project directory structure."""
        try:
            self.ui.debug("Creating FastAPI project directory structure")
            
            created_files = []
            
            # Create directory structure recursively
            created_files.extend(self._create_structure_recursive(
                self.project_structure, output_path
            ))
            
            self.ui.debug(f"Created {len(created_files)} structure files")
            return created_files
            
        except Exception as e:
            self.ui.error(f"Failed to create directory structure: {str(e)}")
            return []
    
    def generate_config_files(self, config_strategy: Dict[str, Any], 
                             analysis_result: Dict[str, Any], output_path: str) -> List[str]:
        """Generate configuration files."""
        try:
            generated_files = []
            
            # Generate main config file
            config_file = self._generate_main_config(config_strategy, analysis_result, output_path)
            if config_file:
                generated_files.append(config_file)
            
            # Generate database config
            db_config_file = self._generate_database_config(analysis_result, output_path)
            if db_config_file:
                generated_files.append(db_config_file)
            
            # Generate .env.example
            env_example_file = self._generate_env_example(config_strategy, output_path)
            if env_example_file:
                generated_files.append(env_example_file)
            
            return generated_files
            
        except Exception as e:
            self.ui.error(f"Failed to generate config files: {str(e)}")
            return []
    
    def generate_main_app(self, analysis_result: Dict[str, Any], 
                         planning_result: Dict[str, Any], output_path: str) -> List[str]:
        """Generate the main FastAPI application file."""
        try:
            # Generate main.py content
            main_content = self._generate_main_app_content(analysis_result, planning_result)
            
            # Write main.py
            app_dir = os.path.join(output_path, 'app')
            main_file = os.path.join(app_dir, 'main.py')
            
            with open(main_file, 'w', encoding='utf-8') as f:
                f.write(main_content)
            
            self.ui.debug(f"Generated main application: {main_file}")
            return [main_file]
            
        except Exception as e:
            self.ui.error(f"Failed to generate main application: {str(e)}")
            return []
    
    def generate_supporting_files(self, analysis_result: Dict[str, Any], 
                                 planning_result: Dict[str, Any], output_path: str) -> List[str]:
        """Generate supporting files (requirements.txt, README.md, etc.)."""
        try:
            generated_files = []
            
            # Generate requirements.txt
            requirements_file = self._generate_requirements_txt(planning_result, output_path)
            if requirements_file:
                generated_files.append(requirements_file)
            
            # Generate README.md
            readme_file = self._generate_readme(analysis_result, planning_result, output_path)
            if readme_file:
                generated_files.append(readme_file)
            
            # Generate Dockerfile
            dockerfile = self._generate_dockerfile(output_path)
            if dockerfile:
                generated_files.append(dockerfile)
            
            # Generate docker-compose.yml
            docker_compose = self._generate_docker_compose(analysis_result, output_path)
            if docker_compose:
                generated_files.append(docker_compose)
            
            # Generate .gitignore
            gitignore_file = self._generate_gitignore(output_path)
            if gitignore_file:
                generated_files.append(gitignore_file)
            
            # Generate basic test file
            test_file = self._generate_basic_test(output_path)
            if test_file:
                generated_files.append(test_file)
            
            return generated_files
            
        except Exception as e:
            self.ui.error(f"Failed to generate supporting files: {str(e)}")
            return []
    
    def _create_structure_recursive(self, structure: Dict[str, Any], 
                                   base_path: str) -> List[str]:
        """Recursively create directory structure."""
        created_files = []
        
        for name, content in structure.items():
            path = os.path.join(base_path, name)
            
            if isinstance(content, dict):
                # It's a directory
                os.makedirs(path, exist_ok=True)
                created_files.extend(self._create_structure_recursive(content, path))
            else:
                # It's a file
                os.makedirs(os.path.dirname(path), exist_ok=True)
                
                if callable(content):
                    # Content is a function that generates the content
                    file_content = content()
                else:
                    # Content is a string
                    file_content = content
                
                if file_content:  # Only create file if there's content
                    with open(path, 'w', encoding='utf-8') as f:
                        f.write(file_content)
                    created_files.append(path)
        
        return created_files
    
    def _generate_main_app_content(self, analysis_result: Dict[str, Any], 
                                  planning_result: Dict[str, Any]) -> str:
        """Generate main FastAPI application content."""
        project_summary = analysis_result.get('project_summary', {})
        api_analysis = analysis_result.get('endpoints_analysis', {})
        
        app_title = "FastAPI Application"
        app_description = "Converted from PHP API"
        
        # Extract info for app metadata
        if project_summary.get('framework_detected'):
            app_description = f"FastAPI application converted from {project_summary['framework_detected']} PHP API"
        
        cors_origins = ["http://localhost:3000", "http://localhost:8080"]
        
        content = f'''"""Main FastAPI application."""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from app.api.v1 import api_router
from app.core.config import settings

# Create FastAPI application
app = FastAPI(
    title="{app_title}",
    description="{app_description}",
    version=settings.VERSION,
    openapi_url=f"{{settings.API_V1_STR}}/openapi.json",
)

# Set up CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins={cors_origins},
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include API router
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/")
async def root():
    """Root endpoint."""
    return {{
        "message": "Welcome to {app_title}",
        "version": settings.VERSION,
        "docs_url": "/docs",
        "openapi_url": f"{{settings.API_V1_STR}}/openapi.json"
    }}

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {{
        "status": "healthy",
        "service": "{app_title}",
        "version": settings.VERSION
    }}

# Global exception handler
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """Global exception handler."""
    return JSONResponse(
        status_code=500,
        content={{"detail": "Internal server error"}}
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )
'''
        
        return content
    
    def _generate_requirements_txt(self, planning_result: Dict[str, Any], 
                                  output_path: str) -> Optional[str]:
        """Generate requirements.txt file."""
        try:
            # Base FastAPI requirements
            requirements = [
                "fastapi>=0.104.0",
                "uvicorn[standard]>=0.24.0",
                "pydantic>=2.5.0",
                "python-multipart>=0.0.6",
                "email-validator>=2.1.0",
                "python-dotenv>=1.0.0",
            ]
            
            # Database requirements
            db_requirements = [
                "sqlalchemy>=2.0.0",
                "alembic>=1.13.0",
                "psycopg2-binary>=2.9.0",  # PostgreSQL
                "aiomysql>=0.2.0",  # MySQL
                "aiosqlite>=0.19.0",  # SQLite
            ]
            requirements.extend(db_requirements)
            
            # Authentication requirements
            auth_requirements = [
                "python-jose[cryptography]>=3.3.0",
                "passlib[bcrypt]>=1.7.4",
            ]
            requirements.extend(auth_requirements)
            
            # HTTP client requirements
            http_requirements = [
                "httpx>=0.25.0",
                "requests>=2.31.0",
            ]
            requirements.extend(http_requirements)
            
            # Development requirements
            dev_requirements = [
                "",
                "# Development dependencies",
                "pytest>=7.4.0",
                "pytest-asyncio>=0.21.0",
                "black>=23.0.0",
                "isort>=5.12.0",
                "flake8>=6.0.0",
                "mypy>=1.7.0",
            ]
            requirements.extend(dev_requirements)
            
            # Add dependencies from planning result
            dependency_conversion = planning_result.get('dependency_conversion', {})
            planned_requirements = dependency_conversion.get('requirements_txt', [])
            
            for req in planned_requirements:
                if isinstance(req, dict):
                    package = req.get('package', '')
                    version = req.get('version', '')
                    if package and version:
                        requirements.append(f"{package}>={version}")
                    elif package:
                        requirements.append(package)
                elif isinstance(req, str):
                    requirements.append(req)
            
            # Write requirements file
            requirements_file = os.path.join(output_path, 'requirements.txt')
            
            with open(requirements_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(requirements))
            
            self.ui.debug(f"Generated requirements.txt: {requirements_file}")
            return requirements_file
            
        except Exception as e:
            self.ui.error(f"Failed to generate requirements.txt: {str(e)}")
            return None
    
    def _generate_readme(self, analysis_result: Dict[str, Any], 
                        planning_result: Dict[str, Any], output_path: str) -> Optional[str]:
        """Generate README.md file."""
        try:
            project_summary = analysis_result.get('project_summary', {})
            endpoints_analysis = analysis_result.get('endpoints_analysis', {})
            
            framework = project_summary.get('framework_detected', 'PHP')
            total_endpoints = endpoints_analysis.get('total_endpoints', 0)
            
            readme_content = f"""# FastAPI Application

This FastAPI application was automatically converted from a {framework} project.

## Project Overview

- **Original Framework**: {framework}
- **Total API Endpoints**: {total_endpoints}
- **Database**: {analysis_result.get('database_analysis', {}).get('database_type', 'Unknown')}
- **Authentication**: {', '.join(endpoints_analysis.get('authentication_methods', ['None']))}

## Getting Started

### Prerequisites

- Python 3.8+
- pip

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd <project-directory>
```

2. Create a virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\\Scripts\\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

4. Set up environment variables:
```bash
cp .env.example .env
# Edit .env with your configuration
```

5. Run database migrations:
```bash
alembic upgrade head
```

### Running the Application

#### Development
```bash
uvicorn app.main:app --reload
```

#### Production
```bash
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

### Using Docker

#### Build and run with Docker:
```bash
docker build -t fastapi-app .
docker run -p 8000:8000 fastapi-app
```

#### Using Docker Compose:
```bash
docker-compose up -d
```

## API Documentation

Once the application is running, you can access:

- **Interactive API Docs (Swagger UI)**: http://localhost:8000/docs
- **Alternative API Docs (ReDoc)**: http://localhost:8000/redoc
- **OpenAPI JSON**: http://localhost:8000/api/v1/openapi.json

## Project Structure

```
app/
├── api/
│   └── v1/
│       └── endpoints/      # API route handlers
├── core/
│   ├── config.py          # Configuration settings
│   ├── database.py        # Database connection
│   ├── deps.py            # Dependencies
│   └── security.py        # Security utilities
├── models/                # SQLAlchemy models
├── schemas/               # Pydantic schemas
├── services/              # Business logic
└── main.py               # FastAPI application
tests/                    # Test files
alembic/                  # Database migrations
```

## Configuration

Key environment variables:

- `DATABASE_URL`: Database connection string
- `SECRET_KEY`: Secret key for JWT tokens
- `DEBUG`: Debug mode (True/False)
- `API_V1_STR`: API version prefix (default: /api/v1)

## Testing

Run tests with pytest:
```bash
pytest
```

Run tests with coverage:
```bash
pytest --cov=app
```

## Database Migrations

Create a new migration:
```bash
alembic revision --autogenerate -m "Description of changes"
```

Apply migrations:
```bash
alembic upgrade head
```

## Development

### Code Quality

Format code:
```bash
black app/
isort app/
```

Lint code:
```bash
flake8 app/
mypy app/
```

### Adding New Features

1. Add new models in `app/models/`
2. Create corresponding schemas in `app/schemas/`
3. Implement business logic in `app/services/`
4. Add API endpoints in `app/api/v1/endpoints/`
5. Write tests in `tests/`

## Deployment

### Environment Variables

Ensure these environment variables are set in production:

- `DATABASE_URL`
- `SECRET_KEY`
- `DEBUG=False`

### Using Docker

The included Dockerfile and docker-compose.yml provide a production-ready setup.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

## License

This project is licensed under the MIT License.
"""
            
            readme_file = os.path.join(output_path, 'README.md')
            
            with open(readme_file, 'w', encoding='utf-8') as f:
                f.write(readme_content)
            
            self.ui.debug(f"Generated README.md: {readme_file}")
            return readme_file
            
        except Exception as e:
            self.ui.error(f"Failed to generate README.md: {str(e)}")
            return None
    
    def _generate_dockerfile(self, output_path: str) -> Optional[str]:
        """Generate Dockerfile."""
        try:
            dockerfile_path = os.path.join(output_path, 'Dockerfile')
            
            with open(dockerfile_path, 'w', encoding='utf-8') as f:
                f.write(self._dockerfile_content())
            
            return dockerfile_path
            
        except Exception as e:
            self.ui.error(f"Failed to generate Dockerfile: {str(e)}")
            return None
    
    def _generate_docker_compose(self, analysis_result: Dict[str, Any], 
                                output_path: str) -> Optional[str]:
        """Generate docker-compose.yml."""
        try:
            compose_path = os.path.join(output_path, 'docker-compose.yml')
            
            with open(compose_path, 'w', encoding='utf-8') as f:
                f.write(self._docker_compose_content())
            
            return compose_path
            
        except Exception as e:
            self.ui.error(f"Failed to generate docker-compose.yml: {str(e)}")
            return None
    
    def _generate_gitignore(self, output_path: str) -> Optional[str]:
        """Generate .gitignore file."""
        try:
            gitignore_path = os.path.join(output_path, '.gitignore')
            
            with open(gitignore_path, 'w', encoding='utf-8') as f:
                f.write(self._gitignore_content())
            
            return gitignore_path
            
        except Exception as e:
            self.ui.error(f"Failed to generate .gitignore: {str(e)}")
            return None
    
    def _generate_basic_test(self, output_path: str) -> Optional[str]:
        """Generate basic test file."""
        try:
            test_content = '''"""Basic API tests."""

import pytest
from fastapi.testclient import TestClient

from app.main import app

client = TestClient(app)

def test_root():
    """Test root endpoint."""
    response = client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert "message" in data

def test_health_check():
    """Test health check endpoint."""
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"

def test_docs():
    """Test that docs are accessible."""
    response = client.get("/docs")
    assert response.status_code == 200

def test_openapi():
    """Test OpenAPI schema."""
    response = client.get("/api/v1/openapi.json")
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/json"
'''
            
            test_file = os.path.join(output_path, 'tests', 'test_main.py')
            os.makedirs(os.path.dirname(test_file), exist_ok=True)
            
            with open(test_file, 'w', encoding='utf-8') as f:
                f.write(test_content)
            
            return test_file
            
        except Exception as e:
            self.ui.error(f"Failed to generate basic test: {str(e)}")
            return None
    
    # Content generation methods for template files
    
    def _config_content(self) -> str:
        """Generate config.py content."""
        return '''"""Application configuration."""

import os
from typing import Optional, List
from pydantic import BaseSettings, Field

class Settings(BaseSettings):
    """Application settings."""
    
    # Application
    PROJECT_NAME: str = "FastAPI Application"
    VERSION: str = "1.0.0"
    DEBUG: bool = Field(False, env="DEBUG")
    API_V1_STR: str = "/api/v1"
    
    # Security
    SECRET_KEY: str = Field(..., env="SECRET_KEY")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # Database
    DATABASE_URL: str = Field(..., env="DATABASE_URL")
    
    # CORS
    BACKEND_CORS_ORIGINS: List[str] = [
        "http://localhost:3000",
        "http://localhost:8080",
    ]
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
'''
    
    def _database_content(self) -> str:
        """Generate database.py content."""
        return '''"""Database configuration."""

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

from app.core.config import settings

# Create database engine
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    echo=settings.DEBUG
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create base class for models
Base = declarative_base()

def get_db():
    """Get database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
'''
    
    def _api_init_content(self) -> str:
        """Generate api/__init__.py content."""
        return '''"""API package."""'''
    
    def _api_v1_init_content(self) -> str:
        """Generate api/v1/__init__.py content."""
        return '''"""API v1 router."""

from fastapi import APIRouter

from app.api.v1.endpoints import auth

api_router = APIRouter()

# Include endpoint routers
api_router.include_router(auth.router, prefix="/auth", tags=["authentication"])

# Add other endpoint routers here as they are created
# api_router.include_router(users.router, prefix="/users", tags=["users"])
# api_router.include_router(posts.router, prefix="/posts", tags=["posts"])
'''
    
    def _services_init_content(self) -> str:
        """Generate services/__init__.py content."""
        return '''"""Services package."""'''
    
    def _conftest_content(self) -> str:
        """Generate tests/conftest.py content."""
        return '''"""Test configuration."""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from app.main import app
from app.core.database import get_db, Base

# Test database URL (use SQLite for tests)
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)

TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture
def db():
    """Create test database."""
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)

@pytest.fixture
def client(db):
    """Create test client."""
    def override_get_db():
        try:
            yield db
        finally:
            db.close()
    
    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()
'''
    
    def _env_example_content(self) -> str:
        """Generate .env.example content."""
        return '''# Application Settings
DEBUG=True
SECRET_KEY=your-secret-key-here
API_V1_STR=/api/v1

# Database
DATABASE_URL=postgresql://user:password@localhost/dbname

# JWT Settings
ACCESS_TOKEN_EXPIRE_MINUTES=30
ALGORITHM=HS256

# CORS Origins (comma-separated)
BACKEND_CORS_ORIGINS=http://localhost:3000,http://localhost:8080
'''
    
    def _dockerfile_content(self) -> str:
        """Generate Dockerfile content."""
        return '''FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    build-essential \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 8000

# Run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
    
    def _docker_compose_content(self) -> str:
        """Generate docker-compose.yml content."""
        return '''version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/fastapi_db
      - SECRET_KEY=your-secret-key-here
      - DEBUG=False
    depends_on:
      - db
    volumes:
      - .:/app
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=fastapi_db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
'''
    
    def _gitignore_content(self) -> str:
        """Generate .gitignore content."""
        return '''# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDEs
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Database
*.db
*.sqlite
*.sqlite3

# Logs
*.log
logs/

# Alembic
alembic/versions/*.py
!alembic/versions/__init__.py

# Docker
.dockerignore

# Backup files
*.backup
*.bak
'''
    
    def _alembic_ini_content(self) -> str:
        """Generate alembic.ini content."""
        return '''# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library that can be
# installed by adding `alembic[tz]` to the pip requirements
# string value is passed to dateutil.tz.gettz()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version number format
version_num_format = %04d

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses
# os.pathsep. If this key is omitted entirely, it falls back to the legacy
# behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = postgresql://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
'''
    
    def _alembic_env_content(self) -> str:
        """Generate alembic/env.py content."""
        return '''"""Alembic environment configuration."""

from logging.config import fileConfig
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context

from app.core.config import settings
from app.core.database import Base

# Import all models here to ensure they are registered with SQLAlchemy
from app.models import *

# this is the Alembic Config object
config = context.config

# Set the SQLAlchemy URL
config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

# Interpret the config file for Python logging.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
'''
    
    def _alembic_script_template(self) -> str:
        """Generate alembic script template."""
        return '''"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade database schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade database schema."""
    ${downgrades if downgrades else "pass"}
'''
    
    def _generate_main_config(self, config_strategy: Dict[str, Any], 
                             analysis_result: Dict[str, Any], output_path: str) -> Optional[str]:
        """Generate enhanced main config file."""
        # The config is already generated by _config_content in the structure
        # This is called separately to potentially enhance it with analysis data
        return None
    
    def _generate_database_config(self, analysis_result: Dict[str, Any], 
                                 output_path: str) -> Optional[str]:
        """Generate enhanced database config."""
        # The database config is already generated by _database_content in the structure
        # This is called separately to potentially enhance it with analysis data
        return None
    
    def _generate_env_example(self, config_strategy: Dict[str, Any], 
                             output_path: str) -> Optional[str]:
        """Generate enhanced .env.example file."""
        # The .env.example is already generated by _env_example_content in the structure
        # This is called separately to potentially enhance it with config strategy data
        return None